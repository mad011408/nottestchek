import { stripe } from "../stripe";
import { workos } from "../workos";
import { getUserIDAndPro } from "@/lib/auth/get-user-id";
import { NextRequest, NextResponse } from "next/server";

export const POST = async (req: NextRequest) => {
  try {
    console.log("=== Starting PentestGPT Migration ===");

    // Get user ID and subscription status
    const { userId, subscription } = await getUserIDAndPro(req);
    console.log(`User ID: ${userId}, Current subscription: ${subscription}`);

    // Only allow migration if user is on free tier
    if (subscription !== "free") {
      console.log("Migration blocked: User is not on free tier");
      return NextResponse.json(
        {
          error: "Migration not allowed",
          message: "You must be on the free tier to migrate from PentestGPT",
        },
        { status: 400 },
      );
    }

    // Get user details
    const user = await workos.userManagement.getUser(userId);
    console.log(`User email: ${user.email}`);

    // Search for active PentestGPT subscriptions for this email
    const customers = await stripe.customers.list({
      email: user.email,
      limit: 100,
    });
    console.log(`Found ${customers.data.length} Stripe customers for email`);

    let pentestGPTSubscription = null;
    let pentestGPTCustomer = null;

    // Look for customers from old PentestGPT system and active subscriptions
    // Old system used firebaseUID or userId in metadata, new system uses workOSOrganizationId
    for (const customer of customers.data) {
      // Only consider customers that don't have the new system metadata (workOSOrganizationId)
      const hasNewMetadata = customer.metadata?.workOSOrganizationId;

      console.log(
        `Checking customer ${customer.id}: hasNewMetadata=${!!hasNewMetadata}`,
      );

      if (!hasNewMetadata) {
        // Check for active subscriptions
        const subscriptions = await stripe.subscriptions.list({
          customer: customer.id,
          status: "active",
          limit: 1,
          expand: [
            "data.default_payment_method",
            "data.latest_invoice.payment_intent.payment_method",
            "data.items",
          ],
        });

        console.log(
          `Customer ${customer.id} has ${subscriptions.data.length} active subscriptions`,
        );

        if (subscriptions.data.length > 0) {
          pentestGPTSubscription = subscriptions.data[0];
          pentestGPTCustomer = customer;
          console.log(
            `Found PentestGPT subscription: ${pentestGPTSubscription.id}`,
          );
          break;
        }
      }
    }

    // If no active PentestGPT subscription found
    if (!pentestGPTSubscription || !pentestGPTCustomer) {
      console.log("No active PentestGPT subscription found for migration");
      return NextResponse.json(
        {
          error: "No active subscription found",
          message:
            "There is no active PentestGPT subscription to migrate for this email address.",
        },
        { status: 404 },
      );
    }

    // Determine plan type
    // Default to pro, check for team indicators
    const quantity = pentestGPTSubscription.items.data[0]?.quantity || 1;
    let planType: "pro" | "team" = "pro";
    let interval: "monthly" | "yearly" = "monthly";

    console.log(`Subscription quantity: ${quantity}`);

    // Check product and price metadata to determine plan type
    const priceId = pentestGPTSubscription.items.data[0]?.price.id;
    if (priceId) {
      const price = await stripe.prices.retrieve(priceId, {
        expand: ["product"],
      });

      console.log(`Price ID: ${priceId}`);
      console.log(`Price metadata:`, price.metadata);

      const product = price.product;
      let productMetadata = {};
      let productName = "";

      if (typeof product === "object" && product !== null && !product.deleted) {
        productMetadata = product.metadata || {};
        productName = product.name || "";
        console.log(`Product name: ${productName}`);
        console.log(`Product metadata:`, productMetadata);
      }

      // Check multiple indicators for team plan:
      // 1. Price metadata
      // 2. Product metadata
      // 3. Product name
      // Note: Don't check quantity since team plans can have quantity = 1
      const isTeamPlan =
        price.metadata?.plan === "team" ||
        (productMetadata as any).plan === "team" ||
        productName.toLowerCase().includes("team");

      if (isTeamPlan) {
        planType = "team";
      }

      // Determine interval from price
      if ((price.recurring as any)?.interval === "year") {
        interval = "yearly";
      } else if ((price.recurring as any)?.interval === "month") {
        interval = "monthly";
      }
    }

    console.log(`Determined plan type: ${planType}, interval: ${interval}`);

    // Check if user has existing organizations
    const existingMemberships =
      await workos.userManagement.listOrganizationMemberships({
        userId,
      });

    console.log(
      `User has ${existingMemberships.data?.length || 0} existing organization memberships`,
    );

    console.log(
      `Existing memberships:`,
      JSON.stringify(existingMemberships, null, 2),
    );

    // Delete existing organizations where the user is an admin, regardless of Stripe customer
    if (existingMemberships.data && existingMemberships.data.length > 0) {
      for (const membership of existingMemberships.data) {
        const orgId = membership.organizationId;

        // Determine if the user is an active admin in this organization
        const roleObjSlug: string | undefined = (membership as any)?.role?.slug;
        const rolesArr: Array<{ slug?: string }> | undefined = (
          membership as any
        )?.roles;
        const hasAdminInRoles = Array.isArray(rolesArr)
          ? rolesArr.some((r) => r?.slug === "admin")
          : false;
        const isActive = (membership as any)?.status === "active";
        const isAdmin =
          (roleObjSlug === "admin" || hasAdminInRoles) && isActive;

        if (!isAdmin) {
          console.log(
            `Skipping organization ${orgId} - user is not an admin in this org`,
          );
          continue;
        }

        try {
          console.log(`Deleting organization (admin-owned): ${orgId}`);
          await workos.organizations.deleteOrganization(orgId);
          console.log(`Successfully deleted organization: ${orgId}`);
        } catch (error) {
          console.error(`Failed to delete organization ${orgId}:`, error);
        }
      }
    }

    // Create new organization with user's email as name
    console.log(`Creating new organization for: ${user.email}`);
    const organization = await workos.organizations.createOrganization({
      name: user.email,
    });
    console.log(`Created organization: ${organization.id}`);

    // Create organization membership for user as admin
    console.log(`Creating organization membership for user as admin`);
    await workos.userManagement.createOrganizationMembership({
      organizationId: organization.id,
      userId,
      roleSlug: "admin",
    });
    console.log(`Organization membership created`);

    // Update Stripe customer metadata to link to new WorkOS organization
    console.log(`Updating Stripe customer ${pentestGPTCustomer.id} metadata`);
    await stripe.customers.update(pentestGPTCustomer.id, {
      metadata: {
        workOSOrganizationId: organization.id,
        source: "pentestgpt-migrated",
      },
    });
    console.log(`Stripe customer metadata updated`);

    // Update WorkOS organization with Stripe customer ID
    // This will allow WorkOS to automatically add entitlements to the access token
    console.log(`Linking WorkOS organization to Stripe customer`);
    await workos.organizations.updateOrganization({
      organization: organization.id,
      stripeCustomerId: pentestGPTCustomer.id,
    });
    console.log(`WorkOS organization updated with Stripe customer ID`);

    console.log("=== Migration completed successfully ===");
    console.log(`Plan: ${planType}, Organization: ${organization.id}`);

    // Create new subscription on the linked customer with matching plan and interval
    const allowedPlans = new Set([
      "pro-monthly-plan",
      "pro-yearly-plan",
      "team-monthly-plan",
      "team-yearly-plan",
    ]);

    const subscriptionLookupKey = `${planType}-${interval}-plan` as
      | "pro-monthly-plan"
      | "pro-yearly-plan"
      | "team-monthly-plan"
      | "team-yearly-plan";

    if (!allowedPlans.has(subscriptionLookupKey)) {
      return NextResponse.json(
        { error: `Unsupported plan mapping: ${subscriptionLookupKey}` },
        { status: 400 },
      );
    }

    // Get the destination price by lookup key (must exist in Stripe)
    const destinationPrices = await stripe.prices.list({
      lookup_keys: [subscriptionLookupKey],
      expand: ["data.product"],
    });

    if (!destinationPrices.data || destinationPrices.data.length === 0) {
      console.error(`No price found for lookup key: ${subscriptionLookupKey}`);
      return NextResponse.json(
        { error: "Destination subscription price not found" },
        { status: 404 },
      );
    }

    const destinationPriceId = destinationPrices.data[0].id;

    // Compute optional trial_end based on remaining time on the old subscription
    const nowInSeconds = Math.floor(Date.now() / 1000);
    // Compute trial end using the legacy subscription's period end. Prefer the maximum
    // across subscription items' current_period_end when expanded; fall back to the
    // top-level current_period_end if available.
    const legacy: any = pentestGPTSubscription;
    let computedPeriodEnd: number | undefined = undefined;
    try {
      const items: Array<any> | undefined = legacy?.items?.data;
      if (Array.isArray(items) && items.length > 0) {
        for (const it of items) {
          const endTs: number | undefined = it?.current_period_end;
          if (typeof endTs === "number") {
            computedPeriodEnd = Math.max(computedPeriodEnd ?? 0, endTs);
          }
        }
      }
    } catch {}
    if (!computedPeriodEnd) {
      const topLevelEnd: number | undefined = legacy?.current_period_end;
      if (typeof topLevelEnd === "number") computedPeriodEnd = topLevelEnd;
    }
    console.log(
      `Legacy subscription period end (for trial): ${computedPeriodEnd ?? "unknown"}`,
    );
    const oldCurrentPeriodEnd: number | undefined = computedPeriodEnd;
    const trialEnd =
      typeof oldCurrentPeriodEnd === "number" &&
      oldCurrentPeriodEnd > nowInSeconds
        ? oldCurrentPeriodEnd
        : undefined;
    console.log(`Computed trial_end: ${trialEnd ?? "none"}`);

    // Always reuse the old subscription's payment method for the new subscription
    try {
      const legacySub: any = pentestGPTSubscription;
      let paymentMethodId: string | undefined;
      let defaultSourceId: string | undefined;

      // Prefer explicit default on legacy subscription
      if (typeof legacySub.default_payment_method === "string") {
        paymentMethodId = legacySub.default_payment_method as string;
      } else if (legacySub.default_payment_method?.id) {
        paymentMethodId = legacySub.default_payment_method.id as string;
      }

      // Fallback to latest invoice's payment intent method
      if (!paymentMethodId) {
        const maybePM =
          legacySub?.latest_invoice?.payment_intent?.payment_method;
        if (typeof maybePM === "string") {
          paymentMethodId = maybePM as string;
        } else if (maybePM?.id) {
          paymentMethodId = maybePM.id as string;
        }
      }

      // Fallback to customer's default payment method
      if (!paymentMethodId) {
        const custDefaultPm = (pentestGPTCustomer as any)?.invoice_settings
          ?.default_payment_method;
        if (typeof custDefaultPm === "string") {
          paymentMethodId = custDefaultPm as string;
        } else if (custDefaultPm?.id) {
          paymentMethodId = custDefaultPm.id as string;
        }
      }

      // Last resort: legacy default source (for older sources)
      if (!paymentMethodId) {
        const custDefaultSource = (pentestGPTCustomer as any)?.default_source;
        if (typeof custDefaultSource === "string") {
          defaultSourceId = custDefaultSource as string;
        } else if (custDefaultSource?.id) {
          defaultSourceId = custDefaultSource.id as string;
        }
      }

      if (!paymentMethodId && !defaultSourceId) {
        console.error(
          "No reusable payment method found on legacy subscription or customer",
        );
        return NextResponse.json(
          {
            error:
              "No reusable payment method found on legacy subscription or customer",
          },
          { status: 400 },
        );
      }

      // Ensure the payment method is attached to the destination customer
      if (paymentMethodId) {
        try {
          const pm = await stripe.paymentMethods.retrieve(paymentMethodId);
          const attachedCustomer = (pm as any).customer;
          if (!attachedCustomer) {
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: pentestGPTCustomer.id,
            });
          } else if (attachedCustomer !== pentestGPTCustomer.id) {
            // If attached to another customer, try to attach (Stripe will error if not allowed)
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: pentestGPTCustomer.id,
            });
          }
        } catch (attachErr) {
          console.warn("Payment method attach attempt result:", attachErr);
        }
      }

      // Set as customer's default to mirror legacy behavior
      if (paymentMethodId) {
        try {
          await stripe.customers.update(pentestGPTCustomer.id, {
            invoice_settings: { default_payment_method: paymentMethodId },
          });
        } catch (custErr) {
          console.warn(
            "Failed setting customer default payment method:",
            custErr,
          );
        }
      }

      // Create the new subscription using the same default payment method
      await stripe.subscriptions.create({
        customer: pentestGPTCustomer.id,
        items: [
          {
            price: destinationPriceId,
            quantity,
          },
        ],
        ...(paymentMethodId ? { default_payment_method: paymentMethodId } : {}),
        ...(defaultSourceId ? { default_source: defaultSourceId } : {}),
        trial_end: trialEnd,
        collection_method: "charge_automatically",
        cancel_at_period_end: false,
      });
    } catch (createErr) {
      console.error("Failed to create destination subscription:", createErr);
      return NextResponse.json(
        { error: "Failed to create destination subscription" },
        { status: 500 },
      );
    }

    // Cancel the old PentestGPT subscription immediately
    try {
      await stripe.subscriptions.cancel(pentestGPTSubscription.id);
    } catch (cancelErr) {
      console.error("Failed to cancel old PentestGPT subscription:", cancelErr);
      // Don't fail the whole migration; proceed
    }

    // Return a minimal response used by the client to decide whether to show team welcome
    const showTeamWelcome = planType === "team" && quantity > 1;
    return NextResponse.json({
      success: true,
      showTeamWelcome,
    });
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : "An error occurred";
    console.error("Migration error:", errorMessage, error);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
};
