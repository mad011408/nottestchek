{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/usePricingDialog.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\nimport type { SubscriptionTier } from \"@/types\";\n\nexport const usePricingDialog = (subscription?: any) => {\n  return {\n    showPricing: false,\n    handleClosePricing: () => {},\n    openPricing: () => {},\n  };\n};\n\nexport const redirectToPricing = () => {};\n"],"names":[],"mappings":";;;;;;AAGO,MAAM,mBAAmB,CAAC;IAC/B,OAAO;QACL,aAAa;QACb,oBAAoB,KAAO;QAC3B,aAAa,KAAO;IACtB;AACF;AAEO,MAAM,oBAAoB,KAAO"}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useFileUpload.ts"],"sourcesContent":["import { useRef, useState, useCallback } from \"react\";\nimport { toast } from \"sonner\";\nimport { useMutation, useAction } from \"convex/react\";\nimport { ConvexError } from \"convex/values\";\nimport { api } from \"@/convex/_generated/api\";\nimport {\n  MAX_FILES_LIMIT,\n  uploadSingleFileToConvex,\n  validateFile,\n  createFileMessagePartFromUploadedFile,\n} from \"@/lib/utils/file-utils\";\nimport { MAX_TOKENS_FILE } from \"@/lib/token-utils\";\nimport { FileProcessingResult, FileSource } from \"@/types/file\";\nimport { useGlobalState } from \"../contexts/GlobalState\";\nimport { Id } from \"@/convex/_generated/dataModel\";\n\nconst USE_S3_STORAGE = process.env.NEXT_PUBLIC_USE_S3_STORAGE === \"true\";\n\nexport const useFileUpload = (mode: \"ask\" | \"agent\" = \"ask\") => {\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const {\n    uploadedFiles,\n    addUploadedFile,\n    updateUploadedFile,\n    removeUploadedFile,\n    subscription,\n    getTotalTokens,\n  } = useGlobalState();\n\n  // Drag and drop state\n  const [isDragOver, setIsDragOver] = useState(false);\n  const [showDragOverlay, setShowDragOverlay] = useState(false);\n  const dragCounterRef = useRef(0);\n\n  // Stubbed Convex hooks\n  const generateUploadUrl = async () => \"stub-url\";\n  const deleteFile = async () => {};\n  const saveFile = async () => ({ url: \"stub-url\", fileId: \"stub-id\", tokens: 0 });\n  const generateS3UploadUrlAction = async () => ({ uploadUrl: \"stub-url\", s3Key: \"stub-key\" });\n\n  // Wrap Convex mutation to match `() => Promise<string>` signature expected by the util\n  const generateUploadUrlFn = useCallback(\n    () => generateUploadUrl({}),\n    [generateUploadUrl],\n  );\n\n  // Helper function to check and validate files before processing\n  const validateAndFilterFiles = useCallback(\n    (files: File[]): FileProcessingResult => {\n      const existingUploadedCount = uploadedFiles.length;\n      const totalFiles = existingUploadedCount + files.length;\n\n      // Check file limits\n      let filesToProcess = files;\n      let truncated = false;\n\n      if (totalFiles > MAX_FILES_LIMIT) {\n        const remainingSlots = MAX_FILES_LIMIT - existingUploadedCount;\n        if (remainingSlots <= 0) {\n          return {\n            validFiles: [],\n            invalidFiles: [],\n            truncated: false,\n            processedCount: 0,\n          };\n        }\n        filesToProcess = files.slice(0, remainingSlots);\n        truncated = true;\n      }\n\n      // Validate each file\n      const validFiles: File[] = [];\n      const invalidFiles: string[] = [];\n\n      for (const file of filesToProcess) {\n        const validation = validateFile(file);\n        if (validation.valid) {\n          validFiles.push(file);\n        } else {\n          invalidFiles.push(`${file.name}: ${validation.error}`);\n        }\n      }\n\n      return {\n        validFiles,\n        invalidFiles,\n        truncated,\n        processedCount: filesToProcess.length,\n      };\n    },\n    [uploadedFiles.length],\n  );\n\n  // Helper function to show feedback messages\n  const showProcessingFeedback = useCallback(\n    (\n      result: FileProcessingResult,\n      source: FileSource,\n      hasRemainingSlots: boolean = true,\n    ) => {\n      const messages: string[] = [];\n\n      // Handle case where no slots are available\n      if (!hasRemainingSlots) {\n        toast.error(\n          `Maximum ${MAX_FILES_LIMIT} files allowed. Please remove some files before adding more.`,\n        );\n        return;\n      }\n\n      // Add truncation message\n      if (result.truncated) {\n        messages.push(\n          `Only ${result.processedCount} files were added. Maximum ${MAX_FILES_LIMIT} files allowed.`,\n        );\n      }\n\n      // Add validation errors\n      if (result.invalidFiles.length > 0) {\n        messages.push(\n          `Some files were invalid:\\n${result.invalidFiles.join(\"\\n\")}`,\n        );\n      }\n\n      // Show error messages if any\n      if (messages.length > 0) {\n        toast.error(messages.join(\"\\n\\n\"));\n      }\n    },\n    [],\n  );\n\n  // Upload file to S3 storage\n  const uploadFileToS3 = useCallback(\n    async (file: File, uploadIndex: number) => {\n      try {\n        // Step 1: Generate presigned S3 upload URL\n        const { uploadUrl, s3Key } = await generateS3UploadUrlAction({\n          fileName: file.name,\n          contentType: file.type || \"application/octet-stream\",\n        });\n\n        // Step 2: Upload file to S3 using presigned URL\n        const uploadResponse = await fetch(uploadUrl, {\n          method: \"PUT\",\n          body: file,\n          headers: { \"Content-Type\": file.type || \"application/octet-stream\" },\n        });\n\n        if (!uploadResponse.ok) {\n          throw new Error(\n            `Failed to upload file ${file.name}: ${uploadResponse.statusText}`,\n          );\n        }\n\n        // Step 3: Save file metadata to database with S3 key\n        const { url, fileId, tokens } = await saveFile({\n          s3Key,\n          name: file.name,\n          mediaType: file.type,\n          size: file.size,\n          mode,\n        });\n\n        // Only check token limit for \"ask\" mode\n        // In \"agent\" mode, files are accessed in sandbox, no token limit applies\n        if (mode === \"ask\") {\n          const currentTotal = getTotalTokens();\n          const newTotal = currentTotal + tokens;\n\n          if (newTotal > MAX_TOKENS_FILE) {\n            // Exceeds limit - delete file from storage and remove from upload list\n            deleteFile({ fileId: fileId as Id<\"files\"> }).catch(console.error);\n            removeUploadedFile(uploadIndex);\n\n            toast.error(\n              `${file.name} exceeds token limit (${newTotal.toLocaleString()}/${MAX_TOKENS_FILE.toLocaleString()} tokens). Tip: Switch to Agent mode to upload larger files.`,\n            );\n            return;\n          }\n        }\n\n        // Set success state with tokens\n        updateUploadedFile(uploadIndex, {\n          tokens,\n          uploading: false,\n          uploaded: true,\n          fileId,\n          url,\n        });\n      } catch (error) {\n        console.error(\"Failed to upload file:\", error);\n\n        // Extract error message from ConvexError or regular Error\n        const errorMessage = (() => {\n          if (error instanceof ConvexError) {\n            const errorData = error.data as { message?: string };\n            return errorData?.message || error.message || \"Upload failed\";\n          }\n          if (error instanceof Error) {\n            return error.message;\n          }\n          return \"Upload failed\";\n        })();\n\n        // Update the upload state to error\n        updateUploadedFile(uploadIndex, {\n          uploading: false,\n          uploaded: false,\n          error: errorMessage,\n        });\n\n        toast.error(errorMessage);\n      }\n    },\n    [\n      generateS3UploadUrlAction,\n      saveFile,\n      getTotalTokens,\n      deleteFile,\n      removeUploadedFile,\n      updateUploadedFile,\n      mode,\n    ],\n  );\n\n  // Upload file to Convex storage\n  const uploadFileToConvex = useCallback(\n    async (file: File, uploadIndex: number) => {\n      try {\n        const { fileId, url, tokens } = await uploadSingleFileToConvex(\n          file,\n          generateUploadUrlFn,\n          saveFile,\n          mode,\n        );\n\n        // Only check token limit for \"ask\" mode\n        // In \"agent\" mode, files are accessed in sandbox, no token limit applies\n        if (mode === \"ask\") {\n          const currentTotal = getTotalTokens();\n          const newTotal = currentTotal + tokens;\n\n          if (newTotal > MAX_TOKENS_FILE) {\n            // Exceeds limit - delete file from storage and remove from upload list\n            deleteFile({ fileId: fileId as Id<\"files\"> }).catch(console.error);\n            removeUploadedFile(uploadIndex);\n\n            toast.error(\n              `${file.name} exceeds token limit (${newTotal.toLocaleString()}/${MAX_TOKENS_FILE.toLocaleString()} tokens). Tip: Switch to Agent mode to upload larger files.`,\n            );\n            return;\n          }\n        }\n\n        // Set success state with tokens\n        updateUploadedFile(uploadIndex, {\n          tokens,\n          uploading: false,\n          uploaded: true,\n          fileId,\n          url,\n        });\n      } catch (error) {\n        console.error(\"Failed to upload file:\", error);\n\n        const errorMessage =\n          error instanceof Error ? error.message : \"Upload failed\";\n\n        // Update the upload state to error\n        updateUploadedFile(uploadIndex, {\n          uploading: false,\n          uploaded: false,\n          error: errorMessage,\n        });\n\n        // Backend already wraps error with file name\n        toast.error(errorMessage);\n      }\n    },\n    [\n      generateUploadUrlFn,\n      saveFile,\n      getTotalTokens,\n      deleteFile,\n      removeUploadedFile,\n      updateUploadedFile,\n      mode,\n    ],\n  );\n\n  // Helper function to start file uploads\n  const startFileUploads = useCallback(\n    (files: File[]) => {\n      const startingIndex = uploadedFiles.length;\n\n      files.forEach((file, index) => {\n        // Add file as \"uploading\" state immediately\n        addUploadedFile({\n          file,\n          uploading: true,\n          uploaded: false,\n        });\n\n        // Start upload in background with correct index\n        // Use S3 or Convex based on feature flag\n        if (USE_S3_STORAGE) {\n          uploadFileToS3(file, startingIndex + index);\n        } else {\n          uploadFileToConvex(file, startingIndex + index);\n        }\n      });\n    },\n    [uploadedFiles.length, addUploadedFile, uploadFileToS3, uploadFileToConvex],\n  );\n\n  // Unified file processing function\n  const processFiles = useCallback(\n    async (files: File[], source: FileSource) => {\n      // Check if user has pro plan for file uploads\n      if (subscription === \"free\") {\n        toast.error(\"Upgrade plan to upload files.\");\n        return;\n      }\n\n      const result = validateAndFilterFiles(files);\n\n      // Check if we have slots available\n      const existingUploadedCount = uploadedFiles.length;\n      const remainingSlots = MAX_FILES_LIMIT - existingUploadedCount;\n      const hasRemainingSlots = remainingSlots > 0;\n\n      // Show feedback messages\n      showProcessingFeedback(result, source, hasRemainingSlots);\n\n      // Start uploads for valid files\n      if (result.validFiles.length > 0 && hasRemainingSlots) {\n        startFileUploads(result.validFiles);\n      }\n    },\n    [\n      subscription,\n      validateAndFilterFiles,\n      showProcessingFeedback,\n      startFileUploads,\n      uploadedFiles.length,\n    ],\n  );\n\n  const handleFileUploadEvent = async (\n    event: React.ChangeEvent<HTMLInputElement>,\n  ) => {\n    const selectedFiles = event.target.files;\n    if (!selectedFiles || selectedFiles.length === 0) return;\n\n    await processFiles(Array.from(selectedFiles), \"upload\");\n\n    // Clear the input\n    if (fileInputRef.current) {\n      fileInputRef.current.value = \"\";\n    }\n  };\n\n  const handleRemoveFile = async (indexToRemove: number) => {\n    const uploadedFile = uploadedFiles[indexToRemove];\n\n    // If the file was uploaded to Convex, delete it from storage\n    if (uploadedFile?.fileId) {\n      try {\n        await deleteFile({\n          fileId: uploadedFile.fileId as Id<\"files\">,\n        });\n      } catch (error) {\n        console.error(\"Failed to delete file from storage:\", error);\n        toast.error(\"Failed to delete file from storage\");\n      }\n    }\n\n    // removeUploadedFile in GlobalState will automatically handle token removal\n    removeUploadedFile(indexToRemove);\n  };\n\n  const handleAttachClick = () => {\n    fileInputRef.current?.click();\n  };\n\n  const handlePasteEvent = async (event: ClipboardEvent): Promise<boolean> => {\n    const items = event.clipboardData?.items;\n    if (!items) return false;\n\n    const files: File[] = [];\n\n    // Extract files from clipboard\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (item.kind === \"file\") {\n        const file = item.getAsFile();\n        if (file) {\n          files.push(file);\n        }\n      }\n    }\n\n    if (files.length === 0) return false;\n\n    // Prevent default paste behavior to avoid pasting file names as text\n    event.preventDefault();\n\n    await processFiles(files, \"paste\");\n    return true;\n  };\n\n  // Helper to get all uploaded file message parts for sending\n  const getUploadedFileMessageParts = () => {\n    return uploadedFiles\n      .map(createFileMessagePartFromUploadedFile)\n      .filter((part): part is NonNullable<typeof part> => part !== null);\n  };\n\n  // Helper to check if all files have finished uploading\n  const allFilesUploaded = () => {\n    return (\n      uploadedFiles.length > 0 &&\n      uploadedFiles.every((file) => file.uploaded && !file.uploading)\n    );\n  };\n\n  // Helper to check if any files are currently uploading\n  const anyFilesUploading = () => {\n    return uploadedFiles.some((file) => file.uploading);\n  };\n\n  // Drag and drop event handlers\n  const handleDragEnter = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    dragCounterRef.current++;\n\n    if (e.dataTransfer?.items && e.dataTransfer.items.length > 0) {\n      setShowDragOverlay(true);\n    }\n  }, []);\n\n  const handleDragLeave = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    dragCounterRef.current--;\n\n    if (dragCounterRef.current === 0) {\n      setShowDragOverlay(false);\n      setIsDragOver(false);\n    }\n  }, []);\n\n  const handleDragOver = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (e.dataTransfer) {\n      e.dataTransfer.dropEffect = \"copy\";\n    }\n\n    setIsDragOver(true);\n  }, []);\n\n  const handleDrop = useCallback(\n    async (e: DragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Reset drag state\n      setShowDragOverlay(false);\n      setIsDragOver(false);\n      dragCounterRef.current = 0;\n\n      const files = e.dataTransfer?.files;\n      if (!files || files.length === 0) return;\n\n      await processFiles(Array.from(files), \"drop\");\n    },\n    [processFiles],\n  );\n\n  return {\n    fileInputRef,\n    handleFileUploadEvent,\n    handleRemoveFile,\n    handleAttachClick,\n    handlePasteEvent,\n    getUploadedFileMessageParts,\n    allFilesUploaded,\n    anyFilesUploading,\n    getTotalTokens,\n    // Drag and drop state and handlers\n    isDragOver,\n    showDragOverlay,\n    handleDragEnter,\n    handleDragLeave,\n    handleDragOver,\n    handleDrop,\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useFeedback.ts"],"sourcesContent":["import { useState, useCallback, Dispatch, SetStateAction } from \"react\";\nimport { useMutation } from \"convex/react\";\nimport { ConvexError } from \"convex/values\";\nimport { api } from \"@/convex/_generated/api\";\nimport { toast } from \"sonner\";\nimport type { ChatMessage } from \"@/types\";\n\ninterface UseFeedbackProps {\n  messages: ChatMessage[];\n  setMessages: Dispatch<SetStateAction<ChatMessage[]>>;\n}\n\nexport const useFeedback = ({ messages, setMessages }: UseFeedbackProps) => {\n  // Track feedback input state for negative feedback\n  const [feedbackInputMessageId, setFeedbackInputMessageId] = useState<\n    string | null\n  >(null);\n\n  // Stubbed Convex mutation for feedback\n  const createFeedback = async () => {};\n\n  // Handle feedback submission (positive/negative)\n  const handleFeedback = useCallback(\n    async (messageId: string, type: \"positive\" | \"negative\") => {\n      // Find the current message to check existing feedback\n      const currentMessage = messages.find((msg) => msg.id === messageId);\n      const existingFeedback = currentMessage?.metadata?.feedbackType;\n\n      if (type === \"positive\") {\n        // Skip if positive feedback already exists\n        if (existingFeedback === \"positive\") {\n          return;\n        }\n\n        // For positive feedback, save immediately\n        try {\n          await createFeedback({\n            feedback_type: \"positive\",\n            message_id: messageId,\n          });\n\n          // Update local message state and merge metadata\n          setMessages(\n            messages.map((msg) =>\n              msg.id === messageId\n                ? {\n                    ...msg,\n                    metadata: { ...msg.metadata, feedbackType: \"positive\" },\n                  }\n                : msg,\n            ),\n          );\n\n          toast.success(\"Thank you for your feedback!\");\n        } catch (error) {\n          console.error(\"Failed to save feedback:\", error);\n          const errorMessage =\n            error instanceof ConvexError\n              ? (error.data as { message?: string })?.message ||\n                error.message ||\n                \"Failed to save feedback\"\n              : error instanceof Error\n                ? error.message\n                : \"Failed to save feedback. Please try again.\";\n          toast.error(errorMessage);\n        }\n      } else {\n        // For negative feedback\n        if (existingFeedback === \"negative\") {\n          // If negative feedback already exists, just show input for details\n          setFeedbackInputMessageId(messageId);\n          return;\n        }\n\n        // Save negative feedback immediately without details and show input\n        try {\n          await createFeedback({\n            feedback_type: \"negative\",\n            message_id: messageId,\n          });\n\n          // Update local message state and merge metadata\n          setMessages(\n            messages.map((msg) =>\n              msg.id === messageId\n                ? {\n                    ...msg,\n                    metadata: { ...msg.metadata, feedbackType: \"negative\" },\n                  }\n                : msg,\n            ),\n          );\n\n          // Then show input for additional details\n          setFeedbackInputMessageId(messageId);\n        } catch (error) {\n          console.error(\"Failed to save initial negative feedback:\", error);\n          const errorMessage =\n            error instanceof ConvexError\n              ? (error.data as { message?: string })?.message ||\n                error.message ||\n                \"Failed to save feedback\"\n              : error instanceof Error\n                ? error.message\n                : \"Failed to save feedback. Please try again.\";\n          toast.error(errorMessage);\n        }\n      }\n    },\n    [createFeedback, messages, setMessages],\n  );\n\n  // Handle negative feedback details submission (updates existing feedback)\n  const handleFeedbackSubmit = useCallback(\n    async (details: string) => {\n      if (!feedbackInputMessageId) return;\n\n      try {\n        // Update the existing negative feedback with details\n        await createFeedback({\n          feedback_type: \"negative\",\n          feedback_details: details,\n          message_id: feedbackInputMessageId,\n        });\n\n        // Local state already shows negative feedback, just hide the input\n        setFeedbackInputMessageId(null);\n        toast.success(\"Thank you for your feedback!\");\n      } catch (error) {\n        console.error(\"Failed to update feedback details:\", error);\n        const errorMessage =\n          error instanceof ConvexError\n            ? (error.data as { message?: string })?.message ||\n              error.message ||\n              \"Failed to save feedback details\"\n            : error instanceof Error\n              ? error.message\n              : \"Failed to save feedback details. Please try again.\";\n        toast.error(errorMessage);\n      }\n    },\n    [createFeedback, feedbackInputMessageId],\n  );\n\n  // Handle feedback input cancellation\n  const handleFeedbackCancel = useCallback(() => {\n    setFeedbackInputMessageId(null);\n  }, []);\n\n  return {\n    feedbackInputMessageId,\n    handleFeedback,\n    handleFeedbackSubmit,\n    handleFeedbackCancel,\n  };\n};\n"],"names":[],"mappings":";;;;AAAA;AAEA;AAAA;AAEA;;;;AAQO,MAAM,cAAc,CAAC,EAAE,QAAQ,EAAE,WAAW,EAAoB;IACrE,mDAAmD;IACnD,MAAM,CAAC,wBAAwB,0BAA0B,GAAG,IAAA,gaAAQ,EAElE;IAEF,uCAAuC;IACvC,MAAM,iBAAiB,WAAa;IAEpC,iDAAiD;IACjD,MAAM,iBAAiB,IAAA,maAAW,EAChC,OAAO,WAAmB;QACxB,sDAAsD;QACtD,MAAM,iBAAiB,SAAS,IAAI,CAAC,CAAC,MAAQ,IAAI,EAAE,KAAK;QACzD,MAAM,mBAAmB,gBAAgB,UAAU;QAEnD,IAAI,SAAS,YAAY;YACvB,2CAA2C;YAC3C,IAAI,qBAAqB,YAAY;gBACnC;YACF;YAEA,0CAA0C;YAC1C,IAAI;gBACF,MAAM,eAAe;oBACnB,eAAe;oBACf,YAAY;gBACd;gBAEA,gDAAgD;gBAChD,YACE,SAAS,GAAG,CAAC,CAAC,MACZ,IAAI,EAAE,KAAK,YACP;wBACE,GAAG,GAAG;wBACN,UAAU;4BAAE,GAAG,IAAI,QAAQ;4BAAE,cAAc;wBAAW;oBACxD,IACA;gBAIR,iRAAK,CAAC,OAAO,CAAC;YAChB,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,4BAA4B;gBAC1C,MAAM,eACJ,iBAAiB,kPAAW,GACxB,AAAC,MAAM,IAAI,EAA2B,WACtC,MAAM,OAAO,IACb,4BACA,iBAAiB,QACf,MAAM,OAAO,GACb;gBACR,iRAAK,CAAC,KAAK,CAAC;YACd;QACF,OAAO;YACL,wBAAwB;YACxB,IAAI,qBAAqB,YAAY;gBACnC,mEAAmE;gBACnE,0BAA0B;gBAC1B;YACF;YAEA,oEAAoE;YACpE,IAAI;gBACF,MAAM,eAAe;oBACnB,eAAe;oBACf,YAAY;gBACd;gBAEA,gDAAgD;gBAChD,YACE,SAAS,GAAG,CAAC,CAAC,MACZ,IAAI,EAAE,KAAK,YACP;wBACE,GAAG,GAAG;wBACN,UAAU;4BAAE,GAAG,IAAI,QAAQ;4BAAE,cAAc;wBAAW;oBACxD,IACA;gBAIR,yCAAyC;gBACzC,0BAA0B;YAC5B,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,6CAA6C;gBAC3D,MAAM,eACJ,iBAAiB,kPAAW,GACxB,AAAC,MAAM,IAAI,EAA2B,WACtC,MAAM,OAAO,IACb,4BACA,iBAAiB,QACf,MAAM,OAAO,GACb;gBACR,iRAAK,CAAC,KAAK,CAAC;YACd;QACF;IACF,GACA;QAAC;QAAgB;QAAU;KAAY;IAGzC,0EAA0E;IAC1E,MAAM,uBAAuB,IAAA,maAAW,EACtC,OAAO;QACL,IAAI,CAAC,wBAAwB;QAE7B,IAAI;YACF,qDAAqD;YACrD,MAAM,eAAe;gBACnB,eAAe;gBACf,kBAAkB;gBAClB,YAAY;YACd;YAEA,mEAAmE;YACnE,0BAA0B;YAC1B,iRAAK,CAAC,OAAO,CAAC;QAChB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sCAAsC;YACpD,MAAM,eACJ,iBAAiB,kPAAW,GACxB,AAAC,MAAM,IAAI,EAA2B,WACtC,MAAM,OAAO,IACb,oCACA,iBAAiB,QACf,MAAM,OAAO,GACb;YACR,iRAAK,CAAC,KAAK,CAAC;QACd;IACF,GACA;QAAC;QAAgB;KAAuB;IAG1C,qCAAqC;IACrC,MAAM,uBAAuB,IAAA,maAAW,EAAC;QACvC,0BAA0B;IAC5B,GAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 540, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useFileUrlCache.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from \"react\";\nimport { useAction } from \"convex/react\";\nimport { api } from \"@/convex/_generated/api\";\nimport { Id } from \"@/convex/_generated/dataModel\";\nimport { isSupportedImageMediaType } from \"@/lib/utils/file-utils\";\nimport type { ChatMessage } from \"@/types\";\n\ninterface CachedUrl {\n  url: string;\n  timestamp: number;\n}\n\nconst URL_CACHE_EXPIRATION = 50 * 60 * 1000; // 50 minutes (S3 URLs expire in 1 hour)\n\n/**\n * Hook to manage prefetching and caching of file URLs\n *\n * Features:\n * - Batch prefetches URLs for all S3 image files in messages (images need eager loading)\n * - Caches URLs with expiration handling (50 min, before 1 hour S3 expiry)\n * - Provides methods to get and set cached URLs (for lazy-loaded non-image files)\n * - Automatically cleans up expired URLs\n */\nexport function useFileUrlCache(messages: ChatMessage[]) {\n  const getFileUrlsBatchAction = useAction(\n    api.s3Actions.getFileUrlsBatchAction,\n  );\n  const urlCacheRef = useRef<Map<string, CachedUrl>>(new Map());\n  const prefetchedIdsRef = useRef<Set<string>>(new Set());\n\n  // Get cached URL for a file (returns null if expired or not cached)\n  const getCachedUrl = useCallback((fileId: string): string | null => {\n    const cached = urlCacheRef.current.get(fileId);\n    if (!cached) return null;\n\n    // Check if URL has expired\n    const now = Date.now();\n    if (now - cached.timestamp > URL_CACHE_EXPIRATION) {\n      urlCacheRef.current.delete(fileId);\n      prefetchedIdsRef.current.delete(fileId);\n      return null;\n    }\n\n    return cached.url;\n  }, []);\n\n  // Set/update cached URL for a file (used for lazy-loaded non-image files)\n  const setCachedUrl = useCallback((fileId: string, url: string) => {\n    const now = Date.now();\n    urlCacheRef.current.set(fileId, { url, timestamp: now });\n    prefetchedIdsRef.current.add(fileId);\n  }, []);\n\n  // Prefetch image URLs for messages\n  useEffect(() => {\n    async function prefetchImageUrls() {\n      // Track seen fileIds within this run to avoid duplicates\n      const seenInThisRun = new Set<string>();\n      const s3ImageFiles: Array<{\n        fileId: Id<\"files\">;\n        mediaType: string;\n      }> = [];\n\n      for (const message of messages) {\n        if (!message.fileDetails) continue;\n\n        for (const file of message.fileDetails) {\n          // Only process files that:\n          // 1. Have an S3 key (not Convex storage)\n          // 2. Are supported image types\n          // 3. Haven't been prefetched yet\n          // 4. Haven't been seen in this run\n          if (\n            file.s3Key &&\n            file.mediaType &&\n            isSupportedImageMediaType(file.mediaType) &&\n            !prefetchedIdsRef.current.has(file.fileId) &&\n            !seenInThisRun.has(file.fileId)\n          ) {\n            s3ImageFiles.push({\n              fileId: file.fileId,\n              mediaType: file.mediaType,\n            });\n            seenInThisRun.add(file.fileId);\n          }\n        }\n      }\n\n      // Also collect image files from message parts\n      for (const message of messages) {\n        for (const part of message.parts) {\n          if (\n            part.type === \"file\" &&\n            \"fileId\" in part &&\n            \"s3Key\" in part &&\n            part.s3Key &&\n            part.mediaType &&\n            isSupportedImageMediaType(part.mediaType) &&\n            typeof part.fileId === \"string\" &&\n            !prefetchedIdsRef.current.has(part.fileId) &&\n            !seenInThisRun.has(part.fileId)\n          ) {\n            s3ImageFiles.push({\n              fileId: part.fileId as Id<\"files\">,\n              mediaType: part.mediaType,\n            });\n            seenInThisRun.add(part.fileId);\n          }\n        }\n      }\n\n      // If no new images to prefetch, return early\n      if (s3ImageFiles.length === 0) {\n        return;\n      }\n\n      // Batch fetch URLs with deduplicated fileIds\n      try {\n        const fileIds = s3ImageFiles.map((f) => f.fileId);\n        const urlMap = await getFileUrlsBatchAction({ fileIds });\n\n        // Cache the fetched URLs (only if urlMap is valid)\n        if (urlMap && typeof urlMap === \"object\") {\n          const now = Date.now();\n          for (const [fileId, url] of Object.entries(urlMap)) {\n            urlCacheRef.current.set(fileId, { url, timestamp: now });\n            prefetchedIdsRef.current.add(fileId);\n          }\n        }\n      } catch (error) {\n        console.error(\"Failed to prefetch image URLs:\", error);\n      }\n    }\n\n    prefetchImageUrls();\n  }, [messages, getFileUrlsBatchAction]);\n\n  // Cleanup expired URLs periodically\n  useEffect(() => {\n    const cleanupInterval = setInterval(\n      () => {\n        const now = Date.now();\n        const entriesToDelete: string[] = [];\n\n        for (const [fileId, cached] of urlCacheRef.current.entries()) {\n          if (now - cached.timestamp > URL_CACHE_EXPIRATION) {\n            entriesToDelete.push(fileId);\n          }\n        }\n\n        for (const fileId of entriesToDelete) {\n          urlCacheRef.current.delete(fileId);\n          prefetchedIdsRef.current.delete(fileId);\n        }\n      },\n      5 * 60 * 1000,\n    ); // Clean up every 5 minutes\n\n    return () => clearInterval(cleanupInterval);\n  }, []);\n\n  return { getCachedUrl, setCachedUrl };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 671, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useSidebarNavigation.ts"],"sourcesContent":["import { useMemo, useCallback } from \"react\";\nimport type { MouseEvent } from \"react\";\nimport {\n  extractAllSidebarContent,\n  type Message,\n} from \"@/lib/utils/sidebar-utils\";\nimport {\n  isSidebarFile,\n  isSidebarTerminal,\n  isSidebarPython,\n  type SidebarContent,\n} from \"@/types/chat\";\n\ninterface UseSidebarNavigationProps {\n  messages: Message[];\n  sidebarContent: SidebarContent | null;\n  onNavigate?: (content: SidebarContent) => void;\n}\n\nexport const useSidebarNavigation = ({\n  messages,\n  sidebarContent,\n  onNavigate,\n}: UseSidebarNavigationProps) => {\n  const toolExecutions = useMemo(\n    () => extractAllSidebarContent(messages),\n    [messages],\n  );\n\n  const currentIndex = useMemo(() => {\n    if (!sidebarContent) return -1;\n\n    // Try to match by toolCallId first (most reliable)\n    const contentToolCallId =\n      \"toolCallId\" in sidebarContent ? sidebarContent.toolCallId : undefined;\n\n    if (contentToolCallId) {\n      const index = toolExecutions.findIndex(\n        (item) => \"toolCallId\" in item && item.toolCallId === contentToolCallId,\n      );\n      if (index !== -1) return index;\n    }\n\n    // Fallback to content-based matching\n    return toolExecutions.findIndex((item) => {\n      if (isSidebarTerminal(item) && isSidebarTerminal(sidebarContent)) {\n        return (\n          item.command === sidebarContent.command &&\n          item.toolCallId === sidebarContent.toolCallId\n        );\n      }\n      if (isSidebarFile(item) && isSidebarFile(sidebarContent)) {\n        return (\n          item.path === sidebarContent.path &&\n          item.action === sidebarContent.action\n        );\n      }\n      if (isSidebarPython(item) && isSidebarPython(sidebarContent)) {\n        return item.code === sidebarContent.code;\n      }\n      return false;\n    });\n  }, [sidebarContent, toolExecutions]);\n\n  const handlePrev = useCallback(() => {\n    if (currentIndex > 0 && onNavigate) {\n      onNavigate(toolExecutions[currentIndex - 1]);\n    }\n  }, [currentIndex, toolExecutions, onNavigate]);\n\n  const handleNext = useCallback(() => {\n    if (currentIndex < toolExecutions.length - 1 && onNavigate) {\n      onNavigate(toolExecutions[currentIndex + 1]);\n    }\n  }, [currentIndex, toolExecutions, onNavigate]);\n\n  const handleJumpToLive = useCallback(() => {\n    if (toolExecutions.length > 0 && onNavigate) {\n      onNavigate(toolExecutions[toolExecutions.length - 1]);\n    }\n  }, [toolExecutions, onNavigate]);\n\n  const handleSliderClick = useCallback(\n    (e: MouseEvent<HTMLDivElement>) => {\n      if (toolExecutions.length === 0 || !onNavigate) return;\n\n      const rect = e.currentTarget.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const percentage = Math.max(0, Math.min(1, x / rect.width));\n\n      const targetIndex = Math.round(percentage * (toolExecutions.length - 1));\n      const clampedIndex = Math.max(\n        0,\n        Math.min(targetIndex, toolExecutions.length - 1),\n      );\n\n      onNavigate(toolExecutions[clampedIndex]);\n    },\n    [toolExecutions, onNavigate],\n  );\n\n  const getProgressPercentage = useMemo(() => {\n    if (toolExecutions.length <= 1) return 100;\n    const effectiveIndex = Math.max(\n      0,\n      Math.min(currentIndex, toolExecutions.length - 1),\n    );\n    return Math.max(\n      0,\n      Math.min(100, (effectiveIndex / (toolExecutions.length - 1)) * 100),\n    );\n  }, [currentIndex, toolExecutions.length]);\n\n  const isAtLive = currentIndex === toolExecutions.length - 1;\n  const canGoPrev = currentIndex > 0;\n  const canGoNext = currentIndex < toolExecutions.length - 1;\n\n  const maxIndex = Math.max(0, toolExecutions.length - 1);\n\n  return {\n    toolExecutions,\n    currentIndex,\n    maxIndex,\n    handlePrev,\n    handleNext,\n    handleJumpToLive,\n    handleSliderClick,\n    getProgressPercentage,\n    isAtLive,\n    canGoPrev,\n    canGoNext,\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 778, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useChats.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { usePaginatedQuery } from \"convex/react\";\nimport { api } from \"@/convex/_generated/api\";\nimport { useAuth } from \"@workos-inc/authkit-nextjs/components\";\nimport { useGlobalState } from \"../contexts/GlobalState\";\n\n/**\n * Custom hook to handle chat fetching and state management\n * Can be used by multiple components to ensure chats are loaded when needed\n */\nexport const useChats = (shouldFetch: boolean = true) => {\n  const user = { id: \"default-user\" };\n  const setChats = (chats: any) => {};\n\n  // Stubbed paginated chats\n  const paginatedChats = {\n    results: [],\n    status: \"Exhausted\" as const,\n    loadMore: () => {},\n  };\n\n  return paginatedChats;\n};\n"],"names":[],"mappings":";;;;AAAA;AAYO,MAAM,WAAW,CAAC,cAAuB,IAAI;IAClD,MAAM,OAAO;QAAE,IAAI;IAAe;IAClC,MAAM,WAAW,CAAC,SAAgB;IAElC,0BAA0B;IAC1B,MAAM,iBAAiB;QACrB,SAAS,EAAE;QACX,QAAQ;QACR,UAAU,KAAO;IACnB;IAEA,OAAO;AACT"}},
    {"offset": {"line": 800, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/usePentestgptMigration.ts"],"sourcesContent":["\"use client\";\n\nimport React from \"react\";\nimport { toast } from \"sonner\";\nimport { useGlobalState } from \"@/app/contexts/GlobalState\";\n\ntype UsePentestgptMigration = {\n  isMigrating: boolean;\n  migrate: () => Promise<void>;\n};\n\nexport const usePentestgptMigration = (): UsePentestgptMigration => {\n  const { setMigrateFromPentestgptDialogOpen } = useGlobalState();\n  const [isMigrating, setIsMigrating] = React.useState(false);\n\n  const migrate = React.useCallback(async () => {\n    if (isMigrating) return;\n    setIsMigrating(true);\n    try {\n      const response = await fetch(\"/api/migrate-pentestgpt\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n      const data = await response.json();\n\n      if (!response.ok) {\n        const errorMessage = data.message || data.error || \"Migration failed\";\n        toast.error(errorMessage);\n        setMigrateFromPentestgptDialogOpen(false);\n        return;\n      }\n\n      toast.success(\"Migration complete. Updating your account...\");\n\n      try {\n        const url = new URL(window.location.href);\n        url.searchParams.set(\"refresh\", \"entitlements\");\n        url.searchParams.delete(\"confirm-migrate-pentestgpt\");\n        if (data?.showTeamWelcome) {\n          url.searchParams.set(\"team-welcome\", \"true\");\n        }\n        window.location.replace(url.toString());\n      } catch {\n        try {\n          await fetch(\"/api/entitlements\", { credentials: \"include\" });\n        } catch {}\n        window.location.reload();\n      }\n    } catch (error) {\n      toast.error(\"An unexpected error occurred during migration\");\n      setMigrateFromPentestgptDialogOpen(false);\n    } finally {\n      setIsMigrating(false);\n    }\n  }, [isMigrating, setMigrateFromPentestgptDialogOpen]);\n\n  return { isMigrating, migrate };\n};\n\nexport default usePentestgptMigration;\n"],"names":[],"mappings":";;;;;;AAEA;AACA;AACA;AAJA;;;;AAWO,MAAM,yBAAyB;IACpC,MAAM,EAAE,kCAAkC,EAAE,GAAG,IAAA,iJAAc;IAC7D,MAAM,CAAC,aAAa,eAAe,GAAG,+ZAAK,CAAC,QAAQ,CAAC;IAErD,MAAM,UAAU,+ZAAK,CAAC,WAAW,CAAC;QAChC,IAAI,aAAa;QACjB,eAAe;QACf,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,2BAA2B;gBACtD,QAAQ;gBACR,SAAS;oBAAE,gBAAgB;gBAAmB;YAChD;YACA,MAAM,OAAO,MAAM,SAAS,IAAI;YAEhC,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,MAAM,eAAe,KAAK,OAAO,IAAI,KAAK,KAAK,IAAI;gBACnD,iRAAK,CAAC,KAAK,CAAC;gBACZ,mCAAmC;gBACnC;YACF;YAEA,iRAAK,CAAC,OAAO,CAAC;YAEd,IAAI;gBACF,MAAM,MAAM,IAAI,IAAI,OAAO,QAAQ,CAAC,IAAI;gBACxC,IAAI,YAAY,CAAC,GAAG,CAAC,WAAW;gBAChC,IAAI,YAAY,CAAC,MAAM,CAAC;gBACxB,IAAI,MAAM,iBAAiB;oBACzB,IAAI,YAAY,CAAC,GAAG,CAAC,gBAAgB;gBACvC;gBACA,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,QAAQ;YACtC,EAAE,OAAM;gBACN,IAAI;oBACF,MAAM,MAAM,qBAAqB;wBAAE,aAAa;oBAAU;gBAC5D,EAAE,OAAM,CAAC;gBACT,OAAO,QAAQ,CAAC,MAAM;YACxB;QACF,EAAE,OAAO,OAAO;YACd,iRAAK,CAAC,KAAK,CAAC;YACZ,mCAAmC;QACrC,SAAU;YACR,eAAe;QACjB;IACF,GAAG;QAAC;QAAa;KAAmC;IAEpD,OAAO;QAAE;QAAa;IAAQ;AAChC;uCAEe"}},
    {"offset": {"line": 870, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useMessageScroll.ts"],"sourcesContent":["import { useStickToBottom } from \"use-stick-to-bottom\";\nimport { useCallback } from \"react\";\n\nexport const useMessageScroll = () => {\n  const stickToBottom = useStickToBottom({\n    resize: \"smooth\",\n    initial: \"instant\",\n  });\n\n  const scrollToBottom = useCallback(\n    (options?: {\n      force?: boolean;\n      instant?: boolean;\n    }): boolean | Promise<boolean> => {\n      if (options?.instant) {\n        const scrollContainer = stickToBottom.scrollRef.current;\n        if (scrollContainer) {\n          scrollContainer.scrollTop = scrollContainer.scrollHeight;\n        }\n        return true;\n      }\n\n      return stickToBottom.scrollToBottom({\n        animation: \"smooth\",\n        preserveScrollPosition: !options?.force,\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [stickToBottom.scrollToBottom, stickToBottom.scrollRef],\n  );\n\n  return {\n    scrollRef: stickToBottom.scrollRef,\n    contentRef: stickToBottom.contentRef,\n    isAtBottom: stickToBottom.isAtBottom,\n    scrollToBottom,\n  };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,MAAM,mBAAmB;IAC9B,MAAM,gBAAgB,IAAA,2RAAgB,EAAC;QACrC,QAAQ;QACR,SAAS;IACX;IAEA,MAAM,iBAAiB,IAAA,maAAW,EAChC,CAAC;QAIC,IAAI,SAAS,SAAS;YACpB,MAAM,kBAAkB,cAAc,SAAS,CAAC,OAAO;YACvD,IAAI,iBAAiB;gBACnB,gBAAgB,SAAS,GAAG,gBAAgB,YAAY;YAC1D;YACA,OAAO;QACT;QAEA,OAAO,cAAc,cAAc,CAAC;YAClC,WAAW;YACX,wBAAwB,CAAC,SAAS;QACpC;IACF,GACA,uDAAuD;IACvD;QAAC,cAAc,cAAc;QAAE,cAAc,SAAS;KAAC;IAGzD,OAAO;QACL,WAAW,cAAc,SAAS;QAClC,YAAY,cAAc,UAAU;QACpC,YAAY,cAAc,UAAU;QACpC;IACF;AACF"}},
    {"offset": {"line": 911, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useChatHandlers.ts"],"sourcesContent":["import { RefObject, useEffect, useRef } from \"react\";\nimport { useMutation } from \"convex/react\";\nimport { api } from \"@/convex/_generated/api\";\nimport { useGlobalState } from \"../contexts/GlobalState\";\nimport type { ChatMessage, ChatStatus } from \"@/types\";\nimport { Id } from \"@/convex/_generated/dataModel\";\nimport {\n  countInputTokens,\n  getMaxTokensForSubscription,\n  MAX_TOKENS_FILE,\n} from \"@/lib/token-utils\";\nimport { toast } from \"sonner\";\nimport { removeTodosBySourceMessages } from \"@/lib/utils/todo-utils\";\nimport { useDataStream } from \"@/app/components/DataStreamProvider\";\nimport { normalizeMessages } from \"@/lib/utils/message-processor\";\n\ninterface UseChatHandlersProps {\n  chatId: string;\n  messages: ChatMessage[];\n  sendMessage: (message?: any, options?: { body?: any }) => void;\n  stop: () => void;\n  regenerate: (options?: { body?: any }) => void;\n  setMessages: (\n    messages: ChatMessage[] | ((prev: ChatMessage[]) => ChatMessage[]),\n  ) => void;\n  isExistingChat: boolean;\n  activateChatLocally: () => void;\n  status: ChatStatus;\n  isSendingNowRef: RefObject<boolean>;\n  hasManuallyStoppedRef: RefObject<boolean>;\n}\n\nexport const useChatHandlers = ({\n  chatId,\n  messages,\n  sendMessage,\n  stop,\n  regenerate,\n  setMessages,\n  isExistingChat,\n  activateChatLocally,\n  status,\n  isSendingNowRef,\n  hasManuallyStoppedRef,\n}: UseChatHandlersProps) => {\n  const { setIsAutoResuming } = useDataStream();\n  const {\n    input,\n    uploadedFiles,\n    chatMode,\n    setChatTitle,\n    clearInput,\n    clearUploadedFiles,\n    todos,\n    setTodos,\n    setCurrentChatId,\n    isUploadingFiles,\n    subscription,\n    temporaryChatsEnabled,\n    queueMessage,\n    messageQueue,\n    removeQueuedMessage,\n    queueBehavior,\n    sandboxPreference,\n    selectedModel,\n    customSystemPrompt,\n  } = useGlobalState();\n\n  // Avoid stale closure on temporary flag\n  const temporaryChatsEnabledRef = useRef(temporaryChatsEnabled);\n  useEffect(() => {\n    temporaryChatsEnabledRef.current = temporaryChatsEnabled;\n  }, [temporaryChatsEnabled]);\n\n  const deleteLastAssistantMessage = async () => {};\n  const saveAssistantMessage = async () => {};\n  const regenerateWithNewContent = async () => {};\n  const cancelStreamMutation = async () => {};\n  const cancelTempStreamMutation = async () => {};\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsAutoResuming(false);\n\n    // Reset manual stop flag when user submits a new message\n    hasManuallyStoppedRef.current = false;\n\n    // Prevent submission if files are still uploading\n    if (isUploadingFiles) {\n      return;\n    }\n    // Allow submission if there's text input or uploaded files\n    const hasValidFiles = uploadedFiles.some((f) => f.uploaded && f.url);\n    if (input.trim() || hasValidFiles) {\n      // If streaming in Agent mode, check queue behavior\n      if (status === \"streaming\" && chatMode === \"agent\") {\n        const validFiles = uploadedFiles.filter(\n          (file) => file.uploaded && file.url && file.fileId,\n        );\n\n        if (queueBehavior === \"queue\") {\n          // Queue the message - will auto-send after current response completes\n          queueMessage(\n            input,\n            validFiles.map((f) => ({\n              file: f.file,\n              fileId: f.fileId! as Id<\"files\">,\n              url: f.url!,\n            })),\n          );\n          clearInput();\n          clearUploadedFiles();\n          return;\n        } else if (queueBehavior === \"stop-and-send\") {\n          // Immediately stop current stream and send right away\n          stop();\n\n          // Cancel the stream in database and save current message state\n          if (!temporaryChatsEnabledRef.current) {\n            cancelStreamMutation({ chatId }).catch((error) => {\n              console.error(\"Failed to cancel stream:\", error);\n            });\n\n            const lastMessage = messages[messages.length - 1];\n            if (lastMessage && lastMessage.role === \"assistant\") {\n              saveAssistantMessage({\n                id: lastMessage.id,\n                chatId,\n                role: lastMessage.role,\n                parts: lastMessage.parts,\n              }).catch((error) => {\n                console.error(\"Failed to save message on stop:\", error);\n              });\n            }\n          } else {\n            // Temporary chats: signal cancel via temp stream coordination\n            cancelTempStreamMutation({ chatId }).catch(() => {});\n          }\n          // Continue to send the new message immediately below (don't return)\n        }\n      }\n      // Check token limit before sending based on user plan\n      const tokenCount = countInputTokens(input, uploadedFiles);\n      const maxTokens = 120000;\n\n      // Additional validation for Ask mode: ensure files don't exceed Ask mode token limits\n      // This prevents uploading files in Agent mode then switching to Ask mode to send them\n      if (chatMode === \"ask\" && uploadedFiles.length > 0) {\n        const fileTokens = uploadedFiles.reduce(\n          (total, file) => total + (file.tokens || 0),\n          0,\n        );\n        if (fileTokens > maxTokens) {\n          toast.error(\"Cannot send files in Ask mode\", {\n            description: `Files exceed token limit (${fileTokens.toLocaleString()}/${maxTokens.toLocaleString()} tokens).`,\n          });\n          return;\n        }\n      }\n\n      if (tokenCount > maxTokens) {\n        const hasFiles = uploadedFiles.length > 0;\n        toast.error(\"Message is too long\", {\n          description: `Your message is too large (${tokenCount.toLocaleString()} tokens). Please make it shorter${hasFiles ? \" or remove some files\" : \"\"}.`,\n        });\n        return;\n      }\n      if (!isExistingChat && !temporaryChatsEnabledRef.current) {\n        setChatTitle(null);\n        setCurrentChatId(chatId);\n        window.history.replaceState({}, \"\", `/c/${chatId}`);\n        activateChatLocally();\n      }\n\n      try {\n        // Get file objects from uploaded files - URLs are already resolved in global state\n        const validFiles = uploadedFiles.filter(\n          (file) => file.uploaded && file.url && file.fileId,\n        );\n\n        sendMessage(\n          {\n            text: input.trim() || undefined,\n            files:\n              validFiles.length > 0\n                ? validFiles.map((uploadedFile) => ({\n                    type: \"file\" as const,\n                    filename: uploadedFile.file.name,\n                    mediaType: uploadedFile.file.type,\n                    url: uploadedFile.url!,\n                    fileId: uploadedFile.fileId!,\n                  }))\n                : undefined,\n          },\n          {\n            body: {\n              mode: chatMode,\n              todos,\n              temporary: temporaryChatsEnabled,\n              sandboxPreference,\n              selectedModel,\n              customSystemPrompt,\n            },\n          },\n        );\n      } catch (error) {\n        console.error(\"Failed to process files:\", error);\n        // Fallback to text-only message if file processing fails\n        sendMessage(\n          { text: input },\n          {\n            body: {\n              mode: chatMode,\n              todos,\n              temporary: temporaryChatsEnabled,\n              sandboxPreference,\n              selectedModel,\n              customSystemPrompt,\n            },\n          },\n        );\n      }\n\n      clearInput();\n      clearUploadedFiles();\n    }\n  };\n\n  const handleStop = async () => {\n    setIsAutoResuming(false);\n\n    // Set manual stop flag to prevent auto-processing of queue\n    hasManuallyStoppedRef.current = true;\n\n    // Stop the stream immediately (client-side abort)\n    stop();\n\n    // Early return if no messages to process\n    if (messages.length === 0) return;\n\n    try {\n      // Normalize messages to mark incomplete tools as interrupted/completed\n      // This removes shimmer effect from any tools that were in-progress\n      const { messages: normalizedMessages, hasChanges } =\n        normalizeMessages(messages);\n\n      // Update local state if changes were made\n      if (hasChanges) {\n        setMessages(normalizedMessages);\n      }\n\n      // Don't clear queued messages - let them remain in the queue\n      // User can manually delete them if needed\n\n      if (!temporaryChatsEnabled) {\n        // Cancel the stream in database first (sets canceled_at for backend detection)\n        await cancelStreamMutation({ chatId }).catch((error) => {\n          console.error(\"Failed to cancel stream:\", error);\n        });\n\n        // Save the normalized message state to database (with interrupted tools marked as completed)\n        const lastMessage = normalizedMessages[normalizedMessages.length - 1];\n        if (lastMessage?.role === \"assistant\") {\n          await saveAssistantMessage({\n            id: lastMessage.id,\n            chatId,\n            role: lastMessage.role,\n            parts: lastMessage.parts,\n          }).catch((error) => {\n            console.error(\"Failed to save message on stop:\", error);\n          });\n        }\n      } else {\n        // Temporary chats: signal cancel via temp stream coordination\n        await cancelTempStreamMutation({ chatId }).catch(() => {});\n      }\n    } catch (error) {\n      console.error(\"Error in handleStop:\", error);\n    }\n  };\n\n  const handleRegenerate = async () => {\n    setIsAutoResuming(false);\n\n    // Remove only todos from the last assistant message being regenerated.\n    // This ensures that if the new run yields no todos, old assistant todos won't persist,\n    // while preserving todos from previous assistant messages.\n    const lastAssistant = [...messages]\n      .reverse()\n      .find((m) => m.role === \"assistant\");\n    const lastAssistantId = lastAssistant?.id;\n    const cleanedTodos = lastAssistantId\n      ? removeTodosBySourceMessages(todos, [lastAssistantId])\n      : todos;\n    if (cleanedTodos !== todos) setTodos(cleanedTodos);\n\n    // Check if the last assistant message has actual content\n    // If it's empty or has no parts, it was never saved (error occurred)\n    // In this case, we shouldn't delete anything from the database\n    const hasContent = lastAssistant?.parts && lastAssistant.parts.length > 0;\n\n    if (!temporaryChatsEnabled) {\n      // Only delete if the last assistant message has content\n      // This prevents deleting previous valid messages when an error occurred\n      if (hasContent) {\n        await deleteLastAssistantMessage({ chatId, todos: cleanedTodos });\n      }\n      // For persisted chats, backend fetches from database - explicitly send no messages\n      regenerate({\n        body: {\n          mode: chatMode,\n          messages: [],\n          todos: cleanedTodos,\n          regenerate: true,\n          temporary: false,\n          sandboxPreference,\n        },\n      });\n    } else {\n      // For temporary chats, send all messages except the last assistant message\n      const messagesForRegenerate =\n        messages && messages.length > 0 ? messages.slice(0, -1) : messages;\n      regenerate({\n        body: {\n          mode: chatMode,\n          messages: messagesForRegenerate,\n          todos: cleanedTodos,\n          regenerate: true,\n          temporary: true,\n          sandboxPreference,\n        },\n      });\n    }\n  };\n\n  const handleRetry = async () => {\n    setIsAutoResuming(false);\n    const cleanedTodos = removeTodosBySourceMessages(\n      todos,\n      todos\n        .filter((t) => t.sourceMessageId)\n        .map((t) => t.sourceMessageId as string),\n    );\n    if (cleanedTodos !== todos) setTodos(cleanedTodos);\n    if (!temporaryChatsEnabled) {\n      // For persisted chats, backend fetches from database - explicitly send no messages\n      regenerate({\n        body: {\n          mode: chatMode,\n          messages: [],\n          todos: cleanedTodos,\n          regenerate: true,\n          temporary: false,\n          sandboxPreference,\n        },\n      });\n    } else {\n      // For temporary chats, filter out empty assistant message if present (from error)\n      // Check if last message is an empty assistant message\n      const lastMessage = messages[messages.length - 1];\n      const isLastMessageEmptyAssistant =\n        lastMessage?.role === \"assistant\" &&\n        (!lastMessage.parts || lastMessage.parts.length === 0);\n\n      const messagesToSend = isLastMessageEmptyAssistant\n        ? messages.slice(0, -1)\n        : messages;\n\n      regenerate({\n        body: {\n          mode: chatMode,\n          messages: messagesToSend,\n          todos: cleanedTodos,\n          regenerate: true,\n          temporary: true,\n          sandboxPreference,\n        },\n      });\n    }\n  };\n\n  const handleEditMessage = async (messageId: string, newContent: string) => {\n    setIsAutoResuming(false);\n    // Find the edited message index to identify subsequent messages\n    const editedMessageIndex = messages.findIndex((m) => m.id === messageId);\n\n    if (editedMessageIndex !== -1) {\n      // Get all subsequent messages (both user and assistant) that will be removed\n      const subsequentMessages = messages.slice(editedMessageIndex + 1);\n      const idsToClean = subsequentMessages.map((m) => m.id);\n\n      // Also clean todos from the edited message itself if it's an assistant message\n      const editedMessage = messages[editedMessageIndex];\n      if (editedMessage.role === \"assistant\") {\n        idsToClean.push(messageId);\n      }\n\n      // Remove todos linked to the edited message and all subsequent messages\n      if (idsToClean.length > 0) {\n        const updatedTodos = removeTodosBySourceMessages(todos, idsToClean);\n        setTodos(updatedTodos);\n      }\n    }\n\n    if (!temporaryChatsEnabled) {\n      try {\n        await regenerateWithNewContent({\n          messageId: messageId as Id<\"messages\">,\n          newContent,\n        });\n      } catch (error) {\n        // Swallow benign errors (e.g., racing edits where the message was already removed)\n        // Avoid logging to keep console clean\n      }\n    }\n\n    // Update local state to reflect the edit and remove subsequent messages\n    setMessages((prevMessages) => {\n      const editedMessageIndex = prevMessages.findIndex(\n        (msg) => msg.id === messageId,\n      );\n\n      if (editedMessageIndex === -1) return prevMessages;\n\n      const updatedMessages = prevMessages.slice(0, editedMessageIndex + 1);\n      updatedMessages[editedMessageIndex] = {\n        ...updatedMessages[editedMessageIndex],\n        parts: [{ type: \"text\", text: newContent }],\n      };\n\n      return updatedMessages;\n    });\n\n    // Trigger regeneration of assistant response with cleaned todos\n    const cleanedTodosForEdit = (() => {\n      const editedIndex = messages.findIndex((m) => m.id === messageId);\n      if (editedIndex === -1) return todos;\n      const subsequentMessages = messages.slice(editedIndex + 1);\n      const idsToClean = subsequentMessages.map((m) => m.id);\n      const editedMessage = messages[editedIndex];\n      if (editedMessage.role === \"assistant\") idsToClean.push(messageId);\n      return removeTodosBySourceMessages(todos, idsToClean);\n    })();\n\n    // For persisted chats, backend fetches from database\n    // For temporary chats, send all messages up to and including the edited message\n    if (!temporaryChatsEnabled) {\n      regenerate({\n        body: {\n          mode: chatMode,\n          messages: [],\n          todos: cleanedTodosForEdit,\n          regenerate: true,\n          temporary: false,\n          sandboxPreference,\n        },\n      });\n    } else {\n      // For temporary chats, send messages up to and including the edited message\n      const messagesUpToEdit = messages.slice(0, editedMessageIndex + 1);\n      const editedMessage = messages[editedMessageIndex];\n      messagesUpToEdit[editedMessageIndex] = {\n        ...editedMessage,\n        parts: [{ type: \"text\", text: newContent }],\n      };\n\n      regenerate({\n        body: {\n          mode: chatMode,\n          messages: messagesUpToEdit,\n          todos: cleanedTodosForEdit,\n          regenerate: true,\n          temporary: true,\n          sandboxPreference,\n        },\n      });\n    }\n  };\n\n  const handleSendNow = async (messageId: string) => {\n    const message = messageQueue.find((m) => m.id === messageId);\n    if (!message) return;\n\n    // Set flag to prevent auto-processing from interfering\n    isSendingNowRef.current = true;\n\n    // Reset manual stop flag when using Send Now\n    hasManuallyStoppedRef.current = false;\n\n    try {\n      // Remove the message from queue FIRST (before stopping)\n      removeQueuedMessage(messageId);\n\n      // Stop the stream - replicate handleStop logic but WITHOUT clearing the queue\n      setIsAutoResuming(false);\n      stop(); // Client-side abort\n\n      // Normalize messages to mark incomplete tools as interrupted/completed\n      if (messages.length > 0) {\n        const { messages: normalizedMessages, hasChanges } =\n          normalizeMessages(messages);\n\n        // Update local state if changes were made\n        if (hasChanges) {\n          setMessages(normalizedMessages);\n        }\n\n        // Cancel stream and save normalized message state\n        if (!temporaryChatsEnabled) {\n          await cancelStreamMutation({ chatId }).catch((error) => {\n            console.error(\"Failed to cancel stream:\", error);\n          });\n\n          // Save the normalized message state to database\n          const lastMessage = normalizedMessages[normalizedMessages.length - 1];\n          if (lastMessage?.role === \"assistant\") {\n            await saveAssistantMessage({\n              id: lastMessage.id,\n              chatId,\n              role: lastMessage.role,\n              parts: lastMessage.parts,\n            }).catch((error) => {\n              console.error(\"Failed to save message on stop:\", error);\n            });\n          }\n        } else {\n          // Temporary chats: signal cancel via temp stream coordination\n          await cancelTempStreamMutation({ chatId }).catch(() => {});\n        }\n      }\n\n      // Send the queued message immediately\n      const validFiles = message.files || [];\n      const messagePayload: any = {};\n\n      // Only add text if it exists\n      if (message.text) {\n        messagePayload.text = message.text;\n      }\n\n      // Only add files if they exist\n      if (validFiles.length > 0) {\n        messagePayload.files = validFiles.map((f) => ({\n          type: \"file\" as const,\n          filename: f.file.name,\n          mediaType: f.file.type,\n          url: f.url,\n          fileId: f.fileId,\n        }));\n      }\n\n      sendMessage(messagePayload, {\n        body: {\n          mode: chatMode,\n          todos,\n          temporary: temporaryChatsEnabled,\n          sandboxPreference,\n          selectedModel,\n          customSystemPrompt,\n        },\n      });\n    } catch (error) {\n      console.error(\"Failed to send queued message:\", error);\n    } finally {\n      // Clear flag after a brief delay to allow status to change\n      setTimeout(() => {\n        isSendingNowRef.current = false;\n      }, 200);\n    }\n  };\n\n  return {\n    handleSubmit,\n    handleStop,\n    handleRegenerate,\n    handleRetry,\n    handleEditMessage,\n    handleSendNow,\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1390, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useDocumentDragAndDrop.ts"],"sourcesContent":["import { useEffect } from \"react\";\n\ntype DragHandler = (e: DragEvent) => void;\n\nexport const useDocumentDragAndDrop = (handlers: {\n  handleDragEnter: DragHandler;\n  handleDragLeave: DragHandler;\n  handleDragOver: DragHandler;\n  handleDrop: DragHandler;\n}) => {\n  const { handleDragEnter, handleDragLeave, handleDragOver, handleDrop } =\n    handlers;\n\n  useEffect(() => {\n    const onEnter = (e: DragEvent) => handleDragEnter(e);\n    const onLeave = (e: DragEvent) => handleDragLeave(e);\n    const onOver = (e: DragEvent) => handleDragOver(e);\n    const onDrop = (e: DragEvent) => handleDrop(e);\n\n    document.addEventListener(\"dragenter\", onEnter);\n    document.addEventListener(\"dragleave\", onLeave);\n    document.addEventListener(\"dragover\", onOver);\n    document.addEventListener(\"drop\", onDrop);\n\n    return () => {\n      document.removeEventListener(\"dragenter\", onEnter);\n      document.removeEventListener(\"dragleave\", onLeave);\n      document.removeEventListener(\"dragover\", onOver);\n      document.removeEventListener(\"drop\", onDrop);\n    };\n  }, [handleDragEnter, handleDragLeave, handleDragOver, handleDrop]);\n};\n"],"names":[],"mappings":";;;;AAAA;;AAIO,MAAM,yBAAyB,CAAC;IAMrC,MAAM,EAAE,eAAe,EAAE,eAAe,EAAE,cAAc,EAAE,UAAU,EAAE,GACpE;IAEF,IAAA,iaAAS,EAAC;QACR,MAAM,UAAU,CAAC,IAAiB,gBAAgB;QAClD,MAAM,UAAU,CAAC,IAAiB,gBAAgB;QAClD,MAAM,SAAS,CAAC,IAAiB,eAAe;QAChD,MAAM,SAAS,CAAC,IAAiB,WAAW;QAE5C,SAAS,gBAAgB,CAAC,aAAa;QACvC,SAAS,gBAAgB,CAAC,aAAa;QACvC,SAAS,gBAAgB,CAAC,YAAY;QACtC,SAAS,gBAAgB,CAAC,QAAQ;QAElC,OAAO;YACL,SAAS,mBAAmB,CAAC,aAAa;YAC1C,SAAS,mBAAmB,CAAC,aAAa;YAC1C,SAAS,mBAAmB,CAAC,YAAY;YACzC,SAAS,mBAAmB,CAAC,QAAQ;QACvC;IACF,GAAG;QAAC;QAAiB;QAAiB;QAAgB;KAAW;AACnE"}},
    {"offset": {"line": 1424, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useAutoResume.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef } from \"react\";\nimport type { UseChatHelpers } from \"@ai-sdk/react\";\nimport type { ChatMessage } from \"@/types/chat\";\nimport { useDataStream } from \"@/app/components/DataStreamProvider\";\n\nexport interface UseAutoResumeParams {\n  autoResume: boolean;\n  initialMessages: ChatMessage[];\n  resumeStream: UseChatHelpers<ChatMessage>[\"resumeStream\"];\n  setMessages: UseChatHelpers<ChatMessage>[\"setMessages\"];\n}\n\nexport function useAutoResume({\n  autoResume,\n  initialMessages,\n  resumeStream,\n  setMessages,\n}: UseAutoResumeParams) {\n  const { dataStream, setIsAutoResuming } = useDataStream();\n  const hasAutoResumedRef = useRef(false);\n\n  useEffect(() => {\n    if (!autoResume || hasAutoResumedRef.current) return;\n    if (initialMessages.length === 0) return;\n\n    const mostRecentMessage = initialMessages.at(-1);\n\n    if (mostRecentMessage?.role === \"user\") {\n      hasAutoResumedRef.current = true;\n      setIsAutoResuming(true);\n      resumeStream();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [autoResume, initialMessages.length > 0]);\n\n  useEffect(() => {\n    if (!dataStream) return;\n    if (dataStream.length === 0) return;\n\n    const dataPart = dataStream[0];\n    if (dataPart.type === \"data-appendMessage\") {\n      const message = JSON.parse(dataPart.data);\n      setMessages([...initialMessages, message]);\n      // First message arrived, we can allow Stop button again\n      setIsAutoResuming(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dataStream, initialMessages, setMessages]);\n}\n"],"names":[],"mappings":";;;;AAEA;AAGA;AALA;;;AAcO,SAAS,cAAc,EAC5B,UAAU,EACV,eAAe,EACf,YAAY,EACZ,WAAW,EACS;IACpB,MAAM,EAAE,UAAU,EAAE,iBAAiB,EAAE,GAAG,IAAA,yJAAa;IACvD,MAAM,oBAAoB,IAAA,8ZAAM,EAAC;IAEjC,IAAA,iaAAS,EAAC;QACR,IAAI,CAAC,cAAc,kBAAkB,OAAO,EAAE;QAC9C,IAAI,gBAAgB,MAAM,KAAK,GAAG;QAElC,MAAM,oBAAoB,gBAAgB,EAAE,CAAC,CAAC;QAE9C,IAAI,mBAAmB,SAAS,QAAQ;YACtC,kBAAkB,OAAO,GAAG;YAC5B,kBAAkB;YAClB;QACF;IACA,uDAAuD;IACzD,GAAG;QAAC;QAAY,gBAAgB,MAAM,GAAG;KAAE;IAE3C,IAAA,iaAAS,EAAC;QACR,IAAI,CAAC,YAAY;QACjB,IAAI,WAAW,MAAM,KAAK,GAAG;QAE7B,MAAM,WAAW,UAAU,CAAC,EAAE;QAC9B,IAAI,SAAS,IAAI,KAAK,sBAAsB;YAC1C,MAAM,UAAU,KAAK,KAAK,CAAC,SAAS,IAAI;YACxC,YAAY;mBAAI;gBAAiB;aAAQ;YACzC,wDAAwD;YACxD,kBAAkB;QACpB;IACA,uDAAuD;IACzD,GAAG;QAAC;QAAY;QAAiB;KAAY;AAC/C"}},
    {"offset": {"line": 1474, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useLatestRef.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\nexport const useLatestRef = <T>(value: T) => {\n  const ref = useRef<T>(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n};\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,eAAe,CAAI;IAC9B,MAAM,MAAM,IAAA,8ZAAM,EAAI;IACtB,IAAA,iaAAS,EAAC;QACR,IAAI,OAAO,GAAG;IAChB,GAAG;QAAC;KAAM;IACV,OAAO;AACT"}},
    {"offset": {"line": 1493, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/hooks/useUpgrade.ts"],"sourcesContent":["import { useState } from \"react\";\nimport { useAuth } from \"@workos-inc/authkit-nextjs/components\";\n\nexport const useUpgrade = () => {\n  const { user } = useAuth();\n  const [upgradeLoading, setUpgradeLoading] = useState(false);\n  const [upgradeError, setUpgradeError] = useState(\"\");\n\n  const handleUpgrade = async (\n    planKey?:\n      | \"pro-monthly-plan\"\n      | \"ultra-monthly-plan\"\n      | \"pro-yearly-plan\"\n      | \"ultra-yearly-plan\"\n      | \"team-monthly-plan\"\n      | \"team-yearly-plan\",\n    e?: React.MouseEvent<HTMLButtonElement | HTMLDivElement>,\n    quantity?: number,\n    currentSubscription?: \"free\" | \"pro\" | \"ultra\" | \"team\",\n  ) => {\n    e?.preventDefault();\n\n    // Prevent duplicate submits\n    if (upgradeLoading) {\n      return;\n    }\n\n    if (!user) {\n      setUpgradeError(\"Please sign in to upgrade\");\n      return;\n    }\n\n    setUpgradeLoading(true);\n    setUpgradeError(\"\");\n\n    try {\n      const requestBody: { plan: string; quantity?: number } = {\n        plan: planKey || \"pro-monthly-plan\",\n      };\n\n      // Add quantity for team plans\n      if (quantity && quantity > 1) {\n        requestBody.quantity = quantity;\n      }\n\n      // Use regular checkout for new subscriptions (free users)\n      if (!currentSubscription || currentSubscription === \"free\") {\n        const res = await fetch(\"/api/subscribe\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(requestBody),\n        });\n\n        if (!res.ok) {\n          const text = await res.text();\n          throw new Error(`HTTP ${res.status}: ${text}`);\n        }\n\n        const { error, url } = await res.json();\n\n        if (url) {\n          window.location.href = url;\n          return;\n        }\n\n        if (error) {\n          setUpgradeError(`Error: ${error}`);\n        } else {\n          setUpgradeError(\"Unknown error creating checkout session\");\n        }\n      } else {\n        // For existing subscribers, use immediate subscription update\n        // This prevents the \"free credit\" exploit\n        const res = await fetch(\"/api/subscription-details\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            plan: planKey,\n            confirm: true,\n            quantity: quantity,\n          }),\n        });\n\n        if (!res.ok) {\n          const text = await res.text();\n          throw new Error(`HTTP ${res.status}: ${text}`);\n        }\n\n        const result = await res.json();\n\n        if (result.success) {\n          // Subscription updated successfully, refresh to show new plan\n          const url = new URL(window.location.href);\n          url.searchParams.set(\"refresh\", \"entitlements\");\n          url.hash = \"\"; // Remove #pricing hash if present\n          window.location.href = url.toString();\n        } else if (result.invoiceUrl) {\n          // Payment failed, redirect to invoice payment page\n          window.location.href = result.invoiceUrl;\n        } else if (result.error) {\n          setUpgradeError(`Error: ${result.error}`);\n        } else {\n          setUpgradeError(\"Unknown error updating subscription\");\n        }\n      }\n    } catch (err) {\n      // Surface real error messages when err is an Error\n      if (err instanceof Error) {\n        setUpgradeError(err.message);\n      } else {\n        setUpgradeError(\"An unexpected error occurred\");\n      }\n    } finally {\n      setUpgradeLoading(false);\n    }\n  };\n\n  return {\n    upgradeLoading,\n    upgradeError,\n    handleUpgrade,\n    setUpgradeError,\n  };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,MAAM,aAAa;IACxB,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,gaAAO;IACxB,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,gaAAQ,EAAC;IACrD,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,gaAAQ,EAAC;IAEjD,MAAM,gBAAgB,OACpB,SAOA,GACA,UACA;QAEA,GAAG;QAEH,4BAA4B;QAC5B,IAAI,gBAAgB;YAClB;QACF;QAEA,IAAI,CAAC,MAAM;YACT,gBAAgB;YAChB;QACF;QAEA,kBAAkB;QAClB,gBAAgB;QAEhB,IAAI;YACF,MAAM,cAAmD;gBACvD,MAAM,WAAW;YACnB;YAEA,8BAA8B;YAC9B,IAAI,YAAY,WAAW,GAAG;gBAC5B,YAAY,QAAQ,GAAG;YACzB;YAEA,0DAA0D;YAC1D,IAAI,CAAC,uBAAuB,wBAAwB,QAAQ;gBAC1D,MAAM,MAAM,MAAM,MAAM,kBAAkB;oBACxC,QAAQ;oBACR,SAAS;wBACP,gBAAgB;oBAClB;oBACA,MAAM,KAAK,SAAS,CAAC;gBACvB;gBAEA,IAAI,CAAC,IAAI,EAAE,EAAE;oBACX,MAAM,OAAO,MAAM,IAAI,IAAI;oBAC3B,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,IAAI,MAAM,CAAC,EAAE,EAAE,MAAM;gBAC/C;gBAEA,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,MAAM,IAAI,IAAI;gBAErC,IAAI,KAAK;oBACP,OAAO,QAAQ,CAAC,IAAI,GAAG;oBACvB;gBACF;gBAEA,IAAI,OAAO;oBACT,gBAAgB,CAAC,OAAO,EAAE,OAAO;gBACnC,OAAO;oBACL,gBAAgB;gBAClB;YACF,OAAO;gBACL,8DAA8D;gBAC9D,0CAA0C;gBAC1C,MAAM,MAAM,MAAM,MAAM,6BAA6B;oBACnD,QAAQ;oBACR,SAAS;wBACP,gBAAgB;oBAClB;oBACA,MAAM,KAAK,SAAS,CAAC;wBACnB,MAAM;wBACN,SAAS;wBACT,UAAU;oBACZ;gBACF;gBAEA,IAAI,CAAC,IAAI,EAAE,EAAE;oBACX,MAAM,OAAO,MAAM,IAAI,IAAI;oBAC3B,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,IAAI,MAAM,CAAC,EAAE,EAAE,MAAM;gBAC/C;gBAEA,MAAM,SAAS,MAAM,IAAI,IAAI;gBAE7B,IAAI,OAAO,OAAO,EAAE;oBAClB,8DAA8D;oBAC9D,MAAM,MAAM,IAAI,IAAI,OAAO,QAAQ,CAAC,IAAI;oBACxC,IAAI,YAAY,CAAC,GAAG,CAAC,WAAW;oBAChC,IAAI,IAAI,GAAG,IAAI,kCAAkC;oBACjD,OAAO,QAAQ,CAAC,IAAI,GAAG,IAAI,QAAQ;gBACrC,OAAO,IAAI,OAAO,UAAU,EAAE;oBAC5B,mDAAmD;oBACnD,OAAO,QAAQ,CAAC,IAAI,GAAG,OAAO,UAAU;gBAC1C,OAAO,IAAI,OAAO,KAAK,EAAE;oBACvB,gBAAgB,CAAC,OAAO,EAAE,OAAO,KAAK,EAAE;gBAC1C,OAAO;oBACL,gBAAgB;gBAClB;YACF;QACF,EAAE,OAAO,KAAK;YACZ,mDAAmD;YACnD,IAAI,eAAe,OAAO;gBACxB,gBAAgB,IAAI,OAAO;YAC7B,OAAO;gBACL,gBAAgB;YAClB;QACF,SAAU;YACR,kBAAkB;QACpB;IACF;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 1604, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/contexts/FileUrlCacheContext.tsx"],"sourcesContent":["import React, { createContext, useContext } from \"react\";\n\ninterface FileUrlCacheContextValue {\n  getCachedUrl: (fileId: string) => string | null;\n  setCachedUrl: (fileId: string, url: string) => void;\n}\n\nconst FileUrlCacheContext = createContext<FileUrlCacheContextValue | null>(\n  null,\n);\n\nexport function FileUrlCacheProvider({\n  children,\n  getCachedUrl,\n  setCachedUrl,\n}: {\n  children: React.ReactNode;\n  getCachedUrl: (fileId: string) => string | null;\n  setCachedUrl: (fileId: string, url: string) => void;\n}) {\n  return (\n    <FileUrlCacheContext.Provider value={{ getCachedUrl, setCachedUrl }}>\n      {children}\n    </FileUrlCacheContext.Provider>\n  );\n}\n\nexport function useFileUrlCacheContext() {\n  return useContext(FileUrlCacheContext);\n}\n"],"names":[],"mappings":";;;;;;;AAAA;;;AAOA,MAAM,oCAAsB,IAAA,qaAAa,EACvC;AAGK,SAAS,qBAAqB,EACnC,QAAQ,EACR,YAAY,EACZ,YAAY,EAKb;IACC,qBACE,6bAAC,oBAAoB,QAAQ;QAAC,OAAO;YAAE;YAAc;QAAa;kBAC/D;;;;;;AAGP;AAEO,SAAS;IACd,OAAO,IAAA,kaAAU,EAAC;AACpB"}},
    {"offset": {"line": 1637, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport React from \"react\";\nimport { Authenticated, Unauthenticated } from \"convex/react\";\nimport { ChatInput } from \"./components/ChatInput\";\nimport Header from \"./components/Header\";\nimport Footer from \"./components/Footer\";\nimport { Chat } from \"./components/chat\";\nimport PricingDialog from \"./components/PricingDialog\";\nimport TeamPricingDialog from \"./components/TeamPricingDialog\";\nimport { TeamWelcomeDialog } from \"./components/TeamDialogs\";\nimport MigratePentestgptDialog from \"./components/MigratePentestgptDialog\";\nimport { usePricingDialog } from \"./hooks/usePricingDialog\";\nimport { useGlobalState } from \"./contexts/GlobalState\";\nimport { usePentestgptMigration } from \"./hooks/usePentestgptMigration\";\n\n// Simple unauthenticated content that redirects to login on message send\nconst UnauthenticatedContent = () => {\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    // Preserve input draft for later; redirect to login\n    window.location.href = \"/login\";\n  };\n\n  const handleStop = () => {\n    // No-op for unauthenticated users\n  };\n\n  return (\n    <div className=\"h-full bg-background flex flex-col overflow-hidden\">\n      <div className=\"flex-shrink-0\">\n        <Header />\n      </div>\n\n      <div className=\"flex-1 flex flex-col min-h-0\">\n        {/* Centered content area */}\n        <div className=\"flex-1 flex flex-col items-center justify-center px-4 py-8 min-h-0\">\n          <div className=\"w-full max-w-full sm:max-w-[768px] sm:min-w-[390px] flex flex-col items-center space-y-8\">\n            {/* Centered title */}\n            <div className=\"text-center\">\n              <h1 className=\"text-3xl font-bold text-foreground mb-2\">\n                HackerAI\n              </h1>\n              <p className=\"text-muted-foreground\">Your AI pentest assistant</p>\n            </div>\n\n            {/* Centered input */}\n            <div className=\"w-full\">\n              <ChatInput\n                onSubmit={handleSubmit}\n                onStop={handleStop}\n                onSendNow={() => {}}\n                status=\"ready\"\n                isCentered={true}\n                isNewChat={true}\n                clearDraftOnSubmit={false}\n              />\n            </div>\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"flex-shrink-0\">\n          <Footer />\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Authenticated content that shows chat (UUID generated internally)\nconst AuthenticatedContent = () => {\n  return <Chat autoResume={false} />;\n};\n\n// Main page component with Convex authentication\nexport default function Page() {\n  const {\n    subscription,\n    teamPricingDialogOpen,\n    setTeamPricingDialogOpen,\n    teamWelcomeDialogOpen,\n    setTeamWelcomeDialogOpen,\n    migrateFromPentestgptDialogOpen,\n    setMigrateFromPentestgptDialogOpen,\n  } = useGlobalState();\n  const { showPricing, handleClosePricing } = usePricingDialog(subscription);\n\n  const { isMigrating, migrate } = usePentestgptMigration();\n  const searchParams =\n    typeof window !== \"undefined\" ? window.location.search : \"\";\n  const { initialSeats, initialPlan } = React.useMemo(() => {\n    if (typeof window === \"undefined\") {\n      return { initialSeats: 5, initialPlan: \"monthly\" as const };\n    }\n    const urlParams = new URLSearchParams(searchParams);\n    const urlSeats = urlParams.get(\"numSeats\");\n    const urlPlan = urlParams.get(\"selectedPlan\");\n\n    let seats = 5;\n    if (urlSeats) {\n      const parsed = parseInt(urlSeats, 10);\n      if (!isNaN(parsed) && parsed >= 1) {\n        seats = parsed;\n      }\n    }\n\n    const plan = (urlPlan === \"yearly\" ? \"yearly\" : \"monthly\") as\n      | \"monthly\"\n      | \"yearly\";\n\n    return { initialSeats: seats, initialPlan: plan };\n  }, [searchParams]);\n\n  return (\n    <>\n      <Authenticated>\n        <AuthenticatedContent />\n      </Authenticated>\n      <Unauthenticated>\n        <UnauthenticatedContent />\n      </Unauthenticated>\n      <PricingDialog isOpen={showPricing} onClose={handleClosePricing} />\n      <TeamPricingDialog\n        isOpen={teamPricingDialogOpen}\n        onClose={() => setTeamPricingDialogOpen(false)}\n        initialSeats={initialSeats}\n        initialPlan={initialPlan}\n      />\n      <TeamWelcomeDialog\n        open={teamWelcomeDialogOpen}\n        onOpenChange={setTeamWelcomeDialogOpen}\n      />\n      <MigratePentestgptDialog\n        open={migrateFromPentestgptDialogOpen}\n        onOpenChange={setMigrateFromPentestgptDialogOpen}\n        isMigrating={isMigrating}\n        onConfirm={migrate}\n      />\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAdA;;;;;;;;;;;;;;;AAgBA,yEAAyE;AACzE,MAAM,yBAAyB;IAC7B,MAAM,eAAe,CAAC;QACpB,EAAE,cAAc;QAChB,oDAAoD;QACpD,OAAO,QAAQ,CAAC,IAAI,GAAG;IACzB;IAEA,MAAM,aAAa;IACjB,kCAAkC;IACpC;IAEA,qBACE,6bAAC;QAAI,WAAU;;0BACb,6bAAC;gBAAI,WAAU;0BACb,cAAA,6bAAC,uIAAM;;;;;;;;;;0BAGT,6bAAC;gBAAI,WAAU;;kCAEb,6bAAC;wBAAI,WAAU;kCACb,cAAA,6bAAC;4BAAI,WAAU;;8CAEb,6bAAC;oCAAI,WAAU;;sDACb,6bAAC;4CAAG,WAAU;sDAA0C;;;;;;sDAGxD,6bAAC;4CAAE,WAAU;sDAAwB;;;;;;;;;;;;8CAIvC,6bAAC;oCAAI,WAAU;8CACb,cAAA,6bAAC,4IAAS;wCACR,UAAU;wCACV,QAAQ;wCACR,WAAW,KAAO;wCAClB,QAAO;wCACP,YAAY;wCACZ,WAAW;wCACX,oBAAoB;;;;;;;;;;;;;;;;;;;;;;kCAO5B,6bAAC;wBAAI,WAAU;kCACb,cAAA,6bAAC,uIAAM;;;;;;;;;;;;;;;;;;;;;;AAKjB;AAEA,oEAAoE;AACpE,MAAM,uBAAuB;IAC3B,qBAAO,6bAAC,kIAAI;QAAC,YAAY;;;;;;AAC3B;AAGe,SAAS;IACtB,MAAM,EACJ,YAAY,EACZ,qBAAqB,EACrB,wBAAwB,EACxB,qBAAqB,EACrB,wBAAwB,EACxB,+BAA+B,EAC/B,kCAAkC,EACnC,GAAG,IAAA,iJAAc;IAClB,MAAM,EAAE,WAAW,EAAE,kBAAkB,EAAE,GAAG,IAAA,oJAAgB,EAAC;IAE7D,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,IAAA,gKAAsB;IACvD,MAAM,eACJ,sCAAgC,0BAAyB;IAC3D,MAAM,EAAE,YAAY,EAAE,WAAW,EAAE,GAAG,+ZAAK,CAAC,OAAO,CAAC;QAClD,wCAAmC;YACjC,OAAO;gBAAE,cAAc;gBAAG,aAAa;YAAmB;QAC5D;;;QACA,MAAM;QACN,MAAM;QACN,MAAM;QAEN,IAAI;QAQJ,MAAM;IAKR,GAAG;QAAC;KAAa;IAEjB,qBACE;;0BACE,6bAAC,yPAAa;0BACZ,cAAA,6bAAC;;;;;;;;;;0BAEH,6bAAC,2PAAe;0BACd,cAAA,6bAAC;;;;;;;;;;0BAEH,6bAAC,8IAAa;gBAAC,QAAQ;gBAAa,SAAS;;;;;;0BAC7C,6bAAC,kJAAiB;gBAChB,QAAQ;gBACR,SAAS,IAAM,yBAAyB;gBACxC,cAAc;gBACd,aAAa;;;;;;0BAEf,6bAAC,sJAAiB;gBAChB,MAAM;gBACN,cAAc;;;;;;0BAEhB,6bAAC,wJAAuB;gBACtB,MAAM;gBACN,cAAc;gBACd,aAAa;gBACb,WAAW;;;;;;;;AAInB"}}]
}